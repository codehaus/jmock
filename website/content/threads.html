<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
      "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Testing Multithreaded Code</title>
</head>

<body>
<h1>Testing Multithreaded Code</h1>

<p>A question that is frequently asked on the <a
href="http://www.jmock.org">jMock</a> users' <a
href="http://www.jmock.org/mailing-lists.html">mailing list</a> is "how do I
use mock objects to test a class that spawns new threads"? The problem is
that jMock appears to ignore unexpected calls if they are made on a different
thread than that which runs the test itself. The mock object actually does
throw an <code>AssertionFailedError</code> when it receives an unexpected
call, but the error terminates the concurrent thread instead of the test
runner's thread.</p>

<p>Here's an example. We have a guard and an alarm. When the guard notices a
burglar, he should ring the alarm once only.</p>
<pre class="Source Java">public interface Alarm {
	void ring();
}</pre>

<pre class="Source Java">@Test
public void ringsTheAlarmOnceWhenNoticesABurglar() {
	final Alarm alarm = context.mock(Alarm.class);
	Guard guard = new Guard(alarm);
	
	context.checking(new Expectations() {{
		one (alarm).ring();
	}});
	
	guard.notice(new Burglar());
}</pre>

<p>Here's an implementation of Guard that should fail the test:</p>
<pre class="Source Java">public class Guard {
	private Alarm alarm;
	
	public Guard( Alarm alarm ) {
		this.alarm = alarm;
	}
	
	public void notice(Burglar burglar) {
		startRingingTheAlarm();
	}
	
	private void startRingingTheAlarm() {
		Runnable ringAlarmTask = new Runnable() {
			public void run() {
				for (int i = 0; i &lt; 10; i++) {
					alarm.ring();
				}
			}
		};
		
		Thread ringAlarmThread = new Thread(ringAlarmTask);
		ringAlarmThread.start();
	}
}</pre>

<p>Although that implementation is incorrect, the test will appear to pass
because the mock Alarm will throw an AssertionFailedError on the
ringAlarmThread, not the test runner's thread.</p>

<p>The root of the problem is trying to use mock objects for integration
testing. Mock objects are used for unit testing in the traditional sense: to
test units in isolation from other parts of the system. Threads, however, by
their very nature, require some kind of integration test. Concurrency and
synchronisation are system-wide concerns and code that creates threads must
make use of operating system facilities to do so.</p>

<p>A solution is to separate the object that needs to run tasks from the
details of how tasks are run and define an interface between the two. We can
test the object that needs to run tasks by mocking the task runner, and test
the implementation of the task runner in integration tests. Java's standard
concurrency library defines just such an interface: <a
href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/Executor.html">java.util.concurrent.Executor</a>.
In our example, we can pass an Executor to the Guard and change the Guard so
that it asks the executor to run tasks instead of explicitly creating new
threads.</p>

<p>Our test then looks like:</p>
<pre class="Source Java">@Test
public void ringsTheAlarmOnceWhenNoticesABurglar() {
	final Alarm alarm = context.mock(Alarm.class);
	Executor executor = ... // What goes here?
	Guard guard = new Guard(alarm, executor);
	
	context.checking(new Expectations() {{
		one (alarm).ring();
	}});
	
	guard.notice(new Burglar());
}</pre>

<p>But how should we implement the Executor for our test? If we use an
Executor that creates a new thread we'll be back where we started and our
tests will still, wrongly, appear to pass. We need to run the task in the
same thread as the test runner. To do this we could mock the Executor
interface and use a <a href="custom-stubs.html">custom stub</a> to call back
to the task's run method, but that's over-complicating things. It's much
easier just to write a class that implements the Executor interface and lets
us explicitly run the tasks after the <code>notice(Burglar)</code> method has
returned:</p>
<pre class="Source Java">public class DelayedExecutor implements Executor
	private List&lt;Runnable&gt; delayedTasks = new ArrayList&lt;Runnable&gt;();

	public void execute(Runnable task) {
		delayedTasks.add(task);
	}
	
	public void runTasks() {
		for (Runnable task : delayedTasks) {
			task.run();
		}
                delayedTasks.clear();
	}
}</pre>
<pre class="Java Source">@Test
public void ringsTheAlarmOnceWhenNoticesABurglar() {
	final Alarm alarm = context.mock(Alarm.class);
	DelayedExecutor executor = new DelayedExecutor();
	Guard guard = new Guard(alarm, executor);
	
	context.checking(new Expectations() {{
		one (alarm).ring();
	}});
	
	guard.notice(new Burglar());
	executor.runTasks();	
}</pre>

<p>And the implementation of the Guard that uses an Executor looks like
this:</p>
<pre class="Source Java">public class Guard {
	private Alarm alarm;
	private Executor executor;
	
	public Guard(Alarm alarm, Executor executor) {
		this.alarm = alarm;
		this.executor = executor;
	}
	
	public void notice(Burglar burglar) {
		startRingingTheAlarm();
	}
	
	private void startRingingTheAlarm() {
		Runnable ringAlarmTask = new Runnable() {
			public void run() {
				for (int i = 0; i &lt; 10; i++) {
					alarm.ring();
				}
			}
		};
		executor.execute(ringAlarmTask);
	}
}</pre>

<p>It's still not correct, but at least our tests can detect the error
now!</p>

<p>Beyond easy testing, the advantage of pulling out the Executor from the
Guard is that the Guard does not hide its concurrency policy within its
implementation. Concurrency is a system-wide concern and should be controlled
outside the Guard object. By passing an appropriate Executor to its
constructor, the application can easily adapt the Guard to the application's
threading policy without having to change the Guard's implementation.</p>
</body>
</html>
