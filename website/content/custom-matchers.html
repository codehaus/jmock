<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
      "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="" />
  <title>Writing Custom Constraints</title>
</head>

<body>
<h1>Writing Custom Matchers</h1>

<p>jMock and Hamcrest provide many Matcher classes and factory functions that
let you <a href="matchers.html">specify the acceptable parameter values of a
method invocation</a>. However, sometimes the predefined constraints do not
let you specify an expectation accurately enough to convey what you mean or
to keep your tests flexible. In such cases, you can easily define new
matchers that seamlessly extend the existing set defined by jMock.</p>

<p>A constraint is an object that implements the Matcher <code><a
href="java:org.jmock.core.Constraint"></a></code>interface. It does two
things:</p>
<ul>
  <li>reports whether a parameter value meets the constraint (the
    <code>matches</code> method).</li>
  <li>provide a readable description to be included in test failure messages
    (the <code>describeTo</code> method from the <a
    href="java:org.jmock.core.SelfDescribing"><code>SelfDescribing</code></a>
    interface).</li>
</ul>

<p>To create a new matcher:</p>
<ol>
  <li><p>Write a class that extends Hamcrest's <code>AbstractMatcher</code>
    base class. The following matcher class tests whether a string starts
    with a given prefix.</p>

    <div class="Source Java">
    <pre>import org.hamcrest.AbstractMatcher;

public class StringStartsWithMatcher extends AbstractMatcher {
    private String prefix;

    public StringStartsWithMatcher( String prefix ) {
        this.prefix = prefix;
    }

    public boolean eval( Object o ) {
        return o instanceof String &amp;&amp; ((String)o).startsWith(prefix);
    }

    public StringBuffer describeTo(Description description) {
        return description.appendText("a string starting with ").appendValue(prefix);
    }
}</pre>
    </div>
  </li>
  <li><p>Write a well-named factory method that creates an instance of your
    new constraint.</p>

    <div class="Source Java">
    <pre>private Constraint aStringStartingWith( String prefix ) {
    return new StringStartsWith(prefix);
}}</pre>
    <p>The point of the factory method is to make the test code read clearly,
    so consider how it will look when used in an expectation. </p>
    </div>
  </li>
  <li><p>Use your factory method to create matchers in your tests. The
    following expectation specifies that the error method of the
    <code>logger</code> object must be called once with an argument that is a
    string starting with "FATAL".</p>

    <div class="Source Java">
    <pre>public class MyTestCase {
    ...

    public void testSomething() {
        ...

        context.checking(new Expectations() {{
            one (logger).error(with(aStringStartingWith("FATAL")));
        }});
        ...
    }
}</pre>
    </div>
  </li>
</ol>

<h2>An Important Rule</h2>

<p><strong>Matcher objects must be stateless.</strong></p>

<p>When <a href="dispatch.html">dispatching</a> each invocation, jMock uses
the matchers to find an expectation that matches the invocation's arguments.
This means that it will call the matchers many times during the test, maybe
even after the expectation has already been matched and invoked. In fact,
jMock gives no guarantees of when and how many times it will call the
matchers. This has no effect on stateless matchers but means that the
function of stateful matchers cannot be predicted.</p>

<p>If you want to maintain state in response to invocations, use an <a
href="custom-actions.html">Action</a>, not a Matcher.</p>

<h2>Where Next?</h2>

<p></p>
</body>
</html>
