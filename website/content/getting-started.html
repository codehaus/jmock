<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
      "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="" />
  <title>Getting Started</title>
</head>

<body>
<h1>Getting Started</h1>

<p>This guide assumes you are familiar with unit-testing and <a
href="http://junit.org/">JUnit</a> 3.8.x. jMock can also be used with JUnit 4
and provides plug-in points that allow you to adapt it to work with any
testing framework of your choice.</p>

<p>For this simple example we are going to test a publish/subscribe message
system. A Publisher sends objects to zero or more Subscribers. We want to
test the Publisher, which involves testing its interactions with its
Subscribers.</p>

<p>The Subscriber interface looks like this:</p>

<pre class="Source Java">interface Subscriber {
    void receive(String message);
}</pre>

<p>We will test that a Publisher sends a message to a single registered
Subscriber. To test interactions between the Publisher and the Subscriber we
will use a mock Subscriber object.</p>

<p>First we must import the jMock classes, define our test fixture class and
create a "Mockery" that represents the context in which the Publisher exists.
The context mocks out the objects that the Publisher collaborates with (in
this case a Subscriber) and checks that they are used correctly.</p>

<pre class="Source Java">import org.jmock.Mockery;

class PublisherTest extends TestCase {
    Mockery context = new Mockery();
    ...    
}</pre>

<p>Now we want to write the method that will run our test:</p>

<pre class="Source Java">public void testOneSubscriberReceivesAMessage() {
    ...
}
</pre>

<p>We will now write the body of the
<code>testOneSubscriberReceivesAMessage</code> method.</p>

<p>We first <i>set up</i> the context in which our test will execute. We
create a Publisher to test. We create a mock Subscriber that should receive
the message. We then register the Subscriber with the Publisher. Finally we
create a message object to publish.</p>

<pre class="Source Java">final Subscriber subscriber = mock(Subscriber.class);

Publisher publisher = new Publisher();
publisher.add(subscriber);

final String message = "message";</pre>

<p>Next we define <i>expectations</i> on the mock Subscriber that specify the
methods that we expect to be called upon it during the test run. We expect
the receive method to be called once with a single argument, the message that
will be sent.</p>

<pre class="Source Java">context.checking(new Expectations() {{
    one (subscriber).receive(message);
}});</pre>

<p>We then <i>execute</i> the code that we want to test.</p>

<pre class="Source Java">publisher.publish(message);</pre>

<p>After the test has finished, jMock will <i>verify</i> that the mock
Subscriber was called as expected. If the expected calls were not made, the
test will fail.</p>

<p>Here is the complete test.</p>

<pre class="Source Java">import org.jmock.Mockery;
import org.jmock.Expectations;

class PublisherTest extends TestCase {
    public void testOneSubscriberReceivesAMessage() {
        // set up
        final Subscriber subscriber = mock(Subscriber.class);
        Publisher publisher = new Publisher();
        publisher.add(subscriber);
        
        final String message = "message";
        
        // expectations
        context.checking(new Expectations() {{
            one (subscriber).receive(message);
        }});

        // execute
        publisher.publish(message);
    }
}</pre>

<p>That concludes this quick introduction. The <a
href="cheat-sheet.html">Cheat Sheet</a> provides a broader overview of the
jMock API. More advanced topics are covered in <a href="cookbook.html">other
cookbook recipes</a>.</p>
</body>
</html>
