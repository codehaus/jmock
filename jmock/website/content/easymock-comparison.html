<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="" />
  <title>Comparing jMock and EasyMock</title>
</head>

<body>
<h1>Comparing jMock and EasyMock</h1>

<p><a href="http://www.easymock.org">EasyMock</a> is also a dynamic mock
object library for Java. What are the main differences between jMock and
EasyMock?</p>

<h2>jMock uses strings to identify methods</h2>

<p>EasyMock therefore works with refactoring tools better than jMock. In
practice we have found that the use of strings in jMock is not a huge
disadvantage, especially if you use tools like IntelliJ or Eclipse which can
apply refactorings to string constants.</p>

<h2>jMock lets you precisely specify required behaviour.</h2>

<p>By default, EasyMock matches actual arguments against expected arguments
using the <code>equals</code> method. This can make tests brittle. Often you
want to ignore an argument or want looser constraints upon an argument.
EasyMock lets you change the way that arguments are matched on a call-by-call
basis, but the syntax is awkward and same matcher applies to <em>all</em>
arguments. There isn't a way to specify a different matcher for different
arguments to the same call.</p>

<div class="Source EasyMock">
<pre>mock.method1( a );
mock.method2( b1, b2 ); // cannot specify that we don't care about argument b2
mockControl.setReturnValue( someResult );
mock.playback();</pre>
</div>

<p>In contrast, jMock forces the user to specify exactly how each actual
argument is matched against expectations. This means that an expectation is
more verbose but the result is a test that precisely and clearly specifies
the expected behaviour of the object. By precisely specifying expected
behaviour, you get a test that breaks only when the actual behaviour is
different from expected behaviour, and does not break when you make unrelated
changes to application code.</p>

<div class="Source JMock">
<pre>mock.expects(once()).method("method1").with( eq(a) );
mock.expects(once()).method("method1").with( same(b1), ANYTHING );</pre>
</div>

<h2>jMock is a specification tool</h2>

<p>jMock is a design tool not a testing tool. jMock's API is designed so that
tests can be read as documentation. In EasyMock's "record/playback" API,
expectations are normal method invocations rather than
<em>specifications</em>, but constraints upon those invocations must be
specified with separate API calls that duplicate information about the
expected call.</p>

<h2>jMock expectations require more typing</h2>

<p>jMock requires that the programmer writing a test be very explicit about
what is and isn't expected. The "call-chain" API style makes expectations
longer than EasyMock's terse "record/playback" style. We were surprised to
find that our users <em>prefered</em> all the extra typing that jMock forced
them to do because the result helped them quickly understand what tests are
specifying.</p>

<h2>jMock can stub methods with side effects</h2>

<p>See <a href="custom-stubs.html">here</a>.</p>

<h2>jMock gives you fine control over invocation order</h2>

<p>jMock lets the programmer specify partial orders of invocations and
specify ordering between invocations on different mock objects.</p>

<h2>jMock is seamlessly extensible</h2>

<p>User extensions to jMock are used in exactly the same way as the built-in
jMock constructs. This makes it easier to read tests, because unimportant
information (whether a constraint is or is not an extension) is hidden from
the reader. User extensions to EasyMock must be used differently to the
functionality provided by EasyMock itself.</p>
</body>
</html>
