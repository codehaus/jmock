<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type"
  content="application/xhtml+xml; charset=UTF-8" />
  <title>Comparing jMock and EasyMock</title>
</head>

<body>
<h1>Comparing jMock and EasyMock</h1>

<p>Like jMock, <a href="http://www.easymock.org">EasyMock</a> is a dynamic
mock object library for Java. What are the main differences between jMock and
EasyMock?</p>

<h2>jMock uses strings to identify methods</h2>

<p>EasyMock uses actual method calls to define expectations. EasyMock
therefore works with an IDE's code completion and refactoring tools better
than jMock.</p>

<div class="Source EasyMock">
<pre>mock.method1( a );
mock.playback();</pre>
</div>

<div class="Source JMock">
<pre>mock.expects(once()).method("method1").with( eq(a) );
mock.expects(once()).method("method1").with( same(b1), ANYTHING );</pre>

<p>In practice we have found that the use of strings in jMock is not a huge
disadvantage, especially if you use tools like IntelliJ or Eclipse which can
apply refactorings to names in string constants. In a TDD process, the method
you are expecting will often not yet be defined in an interface, and so code
completion is not a great advantage.</p>
</div>

<h2>jMock lets you precisely specify required behaviour.</h2>

<p>By default, EasyMock tests actual arguments for equality to expected
arguments using the <code>equals</code> method. This can overspecify expected
behaviour and make tests brittle. Sometimes you want to ignore an argument or
want looser constraints upon an argument's value. EasyMock lets you change
the way that arguments are matched on a call-by-call basis, but the syntax is
awkward and same matcher applies to <em>all</em> arguments. There isn't a way
to specify a different matcher for different arguments to the same call.</p>

<div class="Source EasyMock">
<pre>mock.method1( a );
mock.method2( b1, b2 ); // cannot specify that we don't care about argument b2
mockControl.setReturnValue( method2Result );
mockControl.playback();</pre>
</div>

<p>In contrast, jMock forces the user to specify exactly how each actual
argument is matched against expectations. This means that an expectation is
more verbose but the result is a test that precisely and clearly specifies
the expected behaviour of the object. By precisely specifying expected
behaviour, you get a test that breaks only when the actual behaviour is
different from expected behaviour, and does not break when you make unrelated
changes to application code.</p>

<div class="Source JMock">
<pre>mock.expects(once()).method("method1").with( eq(a) );
mock.expects(once()).method("method1").with( same(b1), ANYTHING )
    .will(returnValue(method2Result));</pre>
</div>

<h2>jMock tries to maximise readability</h2>

<p>jMock is a design tool not a testing tool. jMock's API is designed so that
tests express the design intent of the programmer as clearly as possible and
can later be read as specifications. In EasyMock's "record/playback" API,
expectations are normal method invocations that do not read as specifications
and constraints upon those invocations must be specified with separate API
calls that duplicate information about the expected call and are harder to
read than jMock's expectations.</p>

<h2>jMock expectations require more typing</h2>

<p>The result of the previous two design goals is that jMock requires that
the programmer writing a test be very explicit about what is and isn't
expected. The "call-chain" API style makes expectations longer than
EasyMock's terse "record/playback" style. We were surprised to find that our
users <em>prefered</em> all the extra typing that jMock forced them to do
because the result helped them quickly understand what tests are
specifying.</p>

<h2>jMock can stub methods with side effects</h2>

<p>See <a href="custom-stubs.html">here</a>.</p>

<h2>jMock gives you fine control over invocation order</h2>

<p>jMock lets the programmer specify partial orders of invocations and
specify ordering between invocations on different mock objects.</p>

<h2>jMock's API syntax is extensible</h2>

<p>User extensions to jMock are used in exactly the same way as the built-in
jMock constructs. This makes it easier to read tests, because unimportant
information (whether a constraint is or is not an extension) is hidden from
the reader. User extensions to EasyMock must be used differently to the
functionality provided by EasyMock itself.</p>

<h2>jMock automates more stuff</h2>

<p>jMock automatically verifies mock objects at the end of the test. It is
easy to forget to verify all your mock objects and this can hide test
failures.</p>
</body>
</html>
